/*
Deployment script for AdventureworksLTDW2016

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "AdventureworksLTDW2016"
:setvar DefaultFilePrefix "AdventureworksLTDW2016"
:setvar DefaultDataPath "C:\Program Files\Microsoft SQL Server\MSSQL13.MSSQLSERVER\MSSQL\DATA\"
:setvar DefaultLogPath "C:\Program Files\Microsoft SQL Server\MSSQL13.MSSQLSERVER\MSSQL\DATA\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [master];


GO

IF (DB_ID(N'$(DatabaseName)') IS NOT NULL) 
BEGIN
    ALTER DATABASE [$(DatabaseName)]
    SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
    DROP DATABASE [$(DatabaseName)];
END

GO
PRINT N'Creating $(DatabaseName)...'
GO
CREATE DATABASE [$(DatabaseName)]
    ON 
    PRIMARY(NAME = [$(DatabaseName)], FILENAME = N'$(DefaultDataPath)$(DefaultFilePrefix)_Primary.mdf')
    LOG ON (NAME = [$(DatabaseName)_log], FILENAME = N'$(DefaultLogPath)$(DefaultFilePrefix)_Primary.ldf') COLLATE Latin1_General_100_CI_AI
GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ANSI_NULLS OFF,
                ANSI_PADDING OFF,
                ANSI_WARNINGS OFF,
                ARITHABORT OFF,
                CONCAT_NULL_YIELDS_NULL OFF,
                NUMERIC_ROUNDABORT OFF,
                QUOTED_IDENTIFIER OFF,
                ANSI_NULL_DEFAULT OFF,
                CURSOR_DEFAULT GLOBAL,
                RECOVERY FULL,
                CURSOR_CLOSE_ON_COMMIT OFF,
                AUTO_CREATE_STATISTICS ON,
                AUTO_SHRINK ON,
                AUTO_UPDATE_STATISTICS ON,
                RECURSIVE_TRIGGERS OFF 
            WITH ROLLBACK IMMEDIATE;
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_CLOSE OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ALLOW_SNAPSHOT_ISOLATION OFF;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET READ_COMMITTED_SNAPSHOT OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_UPDATE_STATISTICS_ASYNC OFF,
                PAGE_VERIFY CHECKSUM,
                DATE_CORRELATION_OPTIMIZATION OFF,
                DISABLE_BROKER,
                PARAMETERIZATION SIMPLE,
                SUPPLEMENTAL_LOGGING OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF IS_SRVROLEMEMBER(N'sysadmin') = 1
    BEGIN
        IF EXISTS (SELECT 1
                   FROM   [master].[dbo].[sysdatabases]
                   WHERE  [name] = N'$(DatabaseName)')
            BEGIN
                EXECUTE sp_executesql N'ALTER DATABASE [$(DatabaseName)]
    SET TRUSTWORTHY OFF,
        DB_CHAINING OFF 
    WITH ROLLBACK IMMEDIATE';
            END
    END
ELSE
    BEGIN
        PRINT N'The database settings cannot be modified. You must be a SysAdmin to apply these settings.';
    END


GO
IF IS_SRVROLEMEMBER(N'sysadmin') = 1
    BEGIN
        IF EXISTS (SELECT 1
                   FROM   [master].[dbo].[sysdatabases]
                   WHERE  [name] = N'$(DatabaseName)')
            BEGIN
                EXECUTE sp_executesql N'ALTER DATABASE [$(DatabaseName)]
    SET HONOR_BROKER_PRIORITY OFF 
    WITH ROLLBACK IMMEDIATE';
            END
    END
ELSE
    BEGIN
        PRINT N'The database settings cannot be modified. You must be a SysAdmin to apply these settings.';
    END


GO
ALTER DATABASE [$(DatabaseName)]
    SET TARGET_RECOVERY_TIME = 0 SECONDS 
    WITH ROLLBACK IMMEDIATE;


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET FILESTREAM(NON_TRANSACTED_ACCESS = OFF),
                CONTAINMENT = NONE 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_CREATE_STATISTICS ON(INCREMENTAL = OFF),
                MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT = OFF,
                DELAYED_DURABILITY = DISABLED 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET QUERY_STORE (QUERY_CAPTURE_MODE = ALL, FLUSH_INTERVAL_SECONDS = 900, INTERVAL_LENGTH_MINUTES = 60, MAX_PLANS_PER_QUERY = 200, CLEANUP_POLICY = (STALE_QUERY_THRESHOLD_DAYS = 367), MAX_STORAGE_SIZE_MB = 100) 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET QUERY_STORE = OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE SCOPED CONFIGURATION SET MAXDOP = 0;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET MAXDOP = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET LEGACY_CARDINALITY_ESTIMATION = OFF;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET LEGACY_CARDINALITY_ESTIMATION = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET PARAMETER_SNIFFING = ON;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET PARAMETER_SNIFFING = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET QUERY_OPTIMIZER_HOTFIXES = OFF;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET QUERY_OPTIMIZER_HOTFIXES = PRIMARY;
    END


GO
USE [$(DatabaseName)];


GO
IF fulltextserviceproperty(N'IsFulltextInstalled') = 1
    EXECUTE sp_fulltext_database 'enable';


GO
PRINT N'Creating [Cube]...';


GO
CREATE SCHEMA [Cube]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [DW]...';


GO
CREATE SCHEMA [DW]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [Staging]...';


GO
CREATE SCHEMA [Staging]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [SystemLog]...';


GO
CREATE SCHEMA [SystemLog]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [Cube].[DimSalesOrder]...';


GO
CREATE TABLE [Cube].[DimSalesOrder] (
    [IDSalesOrder]     INT          IDENTITY (1, 1) NOT NULL,
    [SalesOrderNumber] VARCHAR (25) NOT NULL
);


GO
PRINT N'Creating [Cube].[DimPurchaseOrder]...';


GO
CREATE TABLE [Cube].[DimPurchaseOrder] (
    [IDPurchaseOrder] INT          IDENTITY (1, 1) NOT NULL,
    [PurchaseOrder]   VARCHAR (25) NULL
);


GO
PRINT N'Creating [DW].[FactOrders]...';


GO
CREATE TABLE [DW].[FactOrders] (
    [IDOrderDate]         BIGINT       NOT NULL,
    [IDShipDate]          BIGINT       NOT NULL,
    [IDDueDate]           BIGINT       NOT NULL,
    [IDProduct]           SMALLINT     NOT NULL,
    [IDCustomer]          INT          NOT NULL,
    [IDBillingAddress]    INT          NOT NULL,
    [IDShippingAddress]   INT          NOT NULL,
    [IDOrderProvenance]   SMALLINT     NOT NULL,
    [OrderQy]             SMALLINT     NOT NULL,
    [UnitPrice]           MONEY        NOT NULL,
    [Discount]            MONEY        NOT NULL,
    [TaxAmount]           MONEY        NOT NULL,
    [Freight]             MONEY        NOT NULL,
    [SalesOrderNumber]    VARCHAR (25) NOT NULL,
    [PurchareOrderNumber] VARCHAR (25) NULL,
    [LoadID]              INT          NOT NULL,
    CONSTRAINT [FactOrders_PK] PRIMARY KEY CLUSTERED ([IDOrderDate] ASC, [IDProduct] ASC, [IDCustomer] ASC, [IDBillingAddress] ASC, [IDShippingAddress] ASC, [IDShipDate] ASC, [IDDueDate] ASC)
);


GO
PRINT N'Creating [DW].[DimTime]...';


GO
CREATE TABLE [DW].[DimTime] (
    [IDTime]           BIGINT       NOT NULL,
    [DateOfDay]        DATETIME     NOT NULL,
    [DayName]          VARCHAR (20) NOT NULL,
    [DayNbOfTheWeek]   TINYINT      NOT NULL,
    [DayNbOfTheMonth]  TINYINT      NOT NULL,
    [DayNbOfTheYear]   SMALLINT     NOT NULL,
    [MonthName]        VARCHAR (20) NOT NULL,
    [MonthNb]          TINYINT      NOT NULL,
    [WeekNbOfTheMonth] TINYINT      NOT NULL,
    [QuaterNb]         TINYINT      NOT NULL,
    [YearNb]           SMALLINT     NOT NULL,
    [IsWeekDayFlag]    BIT          NOT NULL,
    [IsHolidayFlag]    BIT          NOT NULL,
    CONSTRAINT [DimTime_PK] PRIMARY KEY CLUSTERED ([IDTime] ASC)
);


GO
PRINT N'Creating [DW].[DimProduct]...';


GO
CREATE TABLE [DW].[DimProduct] (
    [IDProduct]          SMALLINT       NOT NULL,
    [ProductNumber]      VARCHAR (25)   NOT NULL,
    [ProductName]        VARCHAR (50)   NOT NULL,
    [EnglishDescription] VARCHAR (400)  NOT NULL,
    [FrenchDescription]  VARCHAR (400)  NOT NULL,
    [Color]              VARCHAR (25)   NOT NULL,
    [Size]               VARCHAR (5)    NOT NULL,
    [Weight]             DECIMAL (8, 2) NOT NULL,
    [StandardCost]       MONEY          NOT NULL,
    [ListPrice]          MONEY          NOT NULL,
    [ModelName]          VARCHAR (50)   NOT NULL,
    [Category]           VARCHAR (50)   NOT NULL,
    [SubCategory]        VARCHAR (50)   NOT NULL,
    [LoadID]             INT            NOT NULL,
    CONSTRAINT [DimProduct_PK] PRIMARY KEY CLUSTERED ([IDProduct] ASC)
);


GO
PRINT N'Creating [DW].[DimOrderProvenance]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
CREATE TABLE [DW].[DimOrderProvenance] (
    [IDOrderProvenance]     SMALLINT     IDENTITY (1, 1) NOT NULL,
    [ProvenanceCode]        SMALLINT     NOT NULL,
    [ProvenanceDescription] VARCHAR (50) NOT NULL,
    [LoadID]                INT          NOT NULL,
    CONSTRAINT [DimOrderProvenance_PK] PRIMARY KEY CLUSTERED ([IDOrderProvenance] ASC)
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [DW].[DimCustomer]...';


GO
CREATE TABLE [DW].[DimCustomer] (
    [IDCustomer]      INT           IDENTITY (1, 1) NOT NULL,
    [CustomerID]      INT           NOT NULL,
    [Title]           VARCHAR (8)   NOT NULL,
    [FirstName]       VARCHAR (50)  NOT NULL,
    [MiddleName]      VARCHAR (50)  NOT NULL,
    [LastName]        VARCHAR (50)  NOT NULL,
    [Suffix]          VARCHAR (10)  NOT NULL,
    [CompanyName]     VARCHAR (128) NOT NULL,
    [ADWSalesPerson]  VARCHAR (256) NOT NULL,
    [EmailAddress]    VARCHAR (50)  NOT NULL,
    [Phone]           VARCHAR (25)  NOT NULL,
    [CustomerEffDate] DATETIME      NOT NULL,
    [CustomerEndDate] DATETIME      NULL,
    [CustomerCurrent] BIT           NOT NULL,
    [LoadID]          INT           NOT NULL,
    CONSTRAINT [DimCustomer_PK] PRIMARY KEY CLUSTERED ([IDCustomer] ASC)
);


GO
PRINT N'Creating [DW].[DimAddress]...';


GO
CREATE TABLE [DW].[DimAddress] (
    [IDAddress]  INT           NOT NULL,
    [Address]    VARCHAR (500) NOT NULL,
    [City]       VARCHAR (100) NOT NULL,
    [ProvState]  VARCHAR (100) NOT NULL,
    [Country]    VARCHAR (100) NOT NULL,
    [PostalCode] VARCHAR (25)  NOT NULL,
    [LoadID]     INT           NOT NULL,
    CONSTRAINT [DimAddress_PK] PRIMARY KEY CLUSTERED ([IDAddress] ASC)
);


GO
PRINT N'Creating [DW].[FactOrdersBig]...';


GO
CREATE TABLE [DW].[FactOrdersBig] (
    [IDOrderDate]         BIGINT       NOT NULL,
    [IDShipDate]          BIGINT       NOT NULL,
    [IDDueDate]           BIGINT       NOT NULL,
    [IDProduct]           SMALLINT     NOT NULL,
    [IDCustomer]          INT          NOT NULL,
    [IDBillingAddress]    INT          NOT NULL,
    [IDShippingAddress]   INT          NOT NULL,
    [IDOrderProvenance]   SMALLINT     NOT NULL,
    [OrderQy]             SMALLINT     NOT NULL,
    [UnitPrice]           MONEY        NOT NULL,
    [Discount]            MONEY        NOT NULL,
    [TaxAmount]           MONEY        NOT NULL,
    [Freight]             MONEY        NOT NULL,
    [SalesOrderNumber]    VARCHAR (25) NOT NULL,
    [PurchaseOrderNumber] VARCHAR (25) NULL,
    [LoadID]              INT          NOT NULL
);


GO
PRINT N'Creating [DW].[DimCustomerBig]...';


GO
CREATE TABLE [DW].[DimCustomerBig] (
    [IDCustomer]     INT           NULL,
    [Title]          VARCHAR (8)   NOT NULL,
    [CustomerID]     NVARCHAR (15) NULL,
    [Phone]          VARCHAR (25)  NOT NULL,
    [EmailAddress]   VARCHAR (50)  NOT NULL,
    [ResellerName]   NVARCHAR (50) NULL,
    [CompanyName]    VARCHAR (128) NOT NULL,
    [ADWSalesPerson] VARCHAR (256) NOT NULL,
    [FirstName]      VARCHAR (50)  NOT NULL,
    [MiddleName]     VARCHAR (50)  NOT NULL,
    [Suffix]         VARCHAR (10)  NOT NULL
);


GO
PRINT N'Creating [Staging].[StgSalesOrderHeader]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
CREATE TABLE [Staging].[StgSalesOrderHeader] (
    [SalesOrderID]           INT           NOT NULL,
    [RevisionNumber]         TINYINT       NOT NULL,
    [OrderDate]              DATETIME      NOT NULL,
    [DueDate]                DATETIME      NOT NULL,
    [ShipDate]               DATETIME      NULL,
    [Status]                 TINYINT       NOT NULL,
    [OnlineOrderFlag]        BIT           NOT NULL,
    [SalesOrderNumber]       VARCHAR (25)  NOT NULL,
    [PurchaseOrderNumber]    VARCHAR (25)  NULL,
    [AccountNumber]          VARCHAR (25)  NULL,
    [CustomerID]             INT           NOT NULL,
    [ShipMethod]             VARCHAR (50)  NOT NULL,
    [CreditCardApprovalCode] VARCHAR (15)  NULL,
    [SubTotal]               MONEY         NOT NULL,
    [TaxAmt]                 MONEY         NOT NULL,
    [Freight]                MONEY         NOT NULL,
    [TotalDue]               MONEY         NOT NULL,
    [Comment]                VARCHAR (128) NULL,
    [ModifiedDate]           DATETIME      NOT NULL,
    [ShipToAddressID]        INT           NOT NULL,
    [BillToAddressID]        INT           NOT NULL,
    [LoadID]                 INT           NOT NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [Staging].[StgSalesOrderDetail]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
CREATE TABLE [Staging].[StgSalesOrderDetail] (
    [SalesOrderID]       INT             NOT NULL,
    [OrderQty]           SMALLINT        NOT NULL,
    [ProductID]          INT             NOT NULL,
    [UnitPrice]          MONEY           NOT NULL,
    [UnitPriceDiscount]  MONEY           NOT NULL,
    [LineTotal]          NUMERIC (38, 6) NOT NULL,
    [ModifiedDate]       DATETIME        NOT NULL,
    [SalesOrderDetailID] INT             NOT NULL,
    [LoadID]             INT             NOT NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [Staging].[StgProductModelProductDescription]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
CREATE TABLE [Staging].[StgProductModelProductDescription] (
    [ProductModelID]       INT          NOT NULL,
    [ProductDescriptionID] INT          NOT NULL,
    [Culture]              VARCHAR (10) NOT NULL,
    [ModifiedDate]         DATETIME     NOT NULL,
    [LoadID]               INT          NOT NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [Staging].[StgProductModel]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
CREATE TABLE [Staging].[StgProductModel] (
    [ProductModelID]     INT          NOT NULL,
    [Name]               VARCHAR (50) NOT NULL,
    [CatalogDescription] XML          NULL,
    [ModifiedDate]       DATETIME     NOT NULL,
    [LoadID]             INT          NOT NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [Staging].[StgProductDescription]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
CREATE TABLE [Staging].[StgProductDescription] (
    [ProductDescriptionID] INT           NOT NULL,
    [Description]          VARCHAR (400) NOT NULL,
    [ModifiedDate]         DATETIME      NOT NULL,
    [LoadID]               INT           NOT NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [Staging].[StgProduct]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
CREATE TABLE [Staging].[StgProduct] (
    [ProductID]         INT            NOT NULL,
    [Name]              VARCHAR (50)   NOT NULL,
    [ProductNumber]     VARCHAR (25)   NOT NULL,
    [Color]             VARCHAR (15)   NULL,
    [StandardCost]      MONEY          NOT NULL,
    [ListPrice]         MONEY          NOT NULL,
    [Size]              VARCHAR (5)    NULL,
    [Weight]            DECIMAL (8, 2) NULL,
    [ProductModelID]    INT            NULL,
    [ProductCategoryID] INT            NOT NULL,
    [SellStartDate]     DATETIME       NOT NULL,
    [SellEndDate]       DATETIME       NULL,
    [DiscontinuedDate]  DATETIME       NULL,
    [ModifiedDate]      DATETIME       NOT NULL,
    [LoadID]            INT            NOT NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [Staging].[StgCustomerAddress]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
CREATE TABLE [Staging].[StgCustomerAddress] (
    [CustomerID]   INT          NOT NULL,
    [AddressID]    INT          NOT NULL,
    [AddressType]  VARCHAR (50) NOT NULL,
    [ModifiedDate] DATETIME     NOT NULL,
    [LoadID]       INT          NOT NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [Staging].[StgCustomer]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
CREATE TABLE [Staging].[StgCustomer] (
    [CustomerID]   INT           NOT NULL,
    [NameStyle]    BIT           NOT NULL,
    [Title]        VARCHAR (8)   NULL,
    [FirstName]    VARCHAR (50)  NOT NULL,
    [MiddleName]   VARCHAR (50)  NULL,
    [LastName]     VARCHAR (50)  NOT NULL,
    [Suffix]       VARCHAR (10)  NULL,
    [CompanyName]  VARCHAR (128) NULL,
    [SalesPerson]  VARCHAR (256) NULL,
    [EmailAddress] VARCHAR (50)  NULL,
    [Phone]        VARCHAR (25)  NULL,
    [PasswordHash] VARCHAR (128) NOT NULL,
    [PasswordSalt] VARCHAR (10)  NOT NULL,
    [ModifiedDate] DATETIME      NOT NULL,
    [LoadID]       INT           NOT NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [Staging].[StgAddress]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
CREATE TABLE [Staging].[StgAddress] (
    [AddressID]     INT          NOT NULL,
    [AddressLine1]  VARCHAR (60) NOT NULL,
    [AddressLine2]  VARCHAR (60) NULL,
    [City]          VARCHAR (30) NOT NULL,
    [StateProvince] VARCHAR (50) NULL,
    [PostalCode]    VARCHAR (15) NOT NULL,
    [CountryRegion] VARCHAR (50) NOT NULL,
    [ModifiedDate]  DATETIME     NOT NULL,
    [LoadID]        INT          NOT NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [Staging].[StgProductCategory]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
CREATE TABLE [Staging].[StgProductCategory] (
    [ProductCategoryID]       INT          NOT NULL,
    [ParentProductCategoryID] INT          NULL,
    [Name]                    VARCHAR (50) NOT NULL,
    [ModifiedDate]            DATETIME     NOT NULL,
    [LoadID]                  INT          NOT NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [SystemLog].[Environment]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
CREATE TABLE [SystemLog].[Environment] (
    [EnvironmentID]       TINYINT       NOT NULL,
    [EnvironmentName]     VARCHAR (100) NOT NULL,
    [SourceEnvironmentID] TINYINT       NOT NULL,
    CONSTRAINT [PK_Environment] PRIMARY KEY CLUSTERED ([EnvironmentID] ASC)
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [SystemLog].[CycleLog]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
CREATE TABLE [SystemLog].[CycleLog] (
    [CycleID]       INT           IDENTITY (1, 1) NOT NULL,
    [ApplicationID] TINYINT       NOT NULL,
    [UserName]      VARCHAR (100) NOT NULL,
    [StartDate]     DATETIME      NOT NULL,
    [EndDate]       DATETIME      NULL,
    [StatusID]      TINYINT       NOT NULL,
    CONSTRAINT [PK_LoadCycle] PRIMARY KEY CLUSTERED ([CycleID] ASC)
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [SystemLog].[BusSubjectArea]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
CREATE TABLE [SystemLog].[BusSubjectArea] (
    [BusSubjectID]   TINYINT       NOT NULL,
    [BusSubjectName] VARCHAR (255) NOT NULL,
    CONSTRAINT [PK_BusSubjectArea] PRIMARY KEY CLUSTERED ([BusSubjectID] ASC)
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [SystemLog].[Application]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
CREATE TABLE [SystemLog].[Application] (
    [ApplicationID]   TINYINT       NOT NULL,
    [ApplicationName] VARCHAR (255) NOT NULL,
    CONSTRAINT [PK_LoadApplication] PRIMARY KEY CLUSTERED ([ApplicationID] ASC)
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [SystemLog].[TransformStatisticMap]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
CREATE TABLE [SystemLog].[TransformStatisticMap] (
    [TransformStatisticMapID]             TINYINT      NOT NULL,
    [TransformStatisticMapName]           VARCHAR (60) NOT NULL,
    [TransformStatisticMapObjectLinkCode] VARCHAR (50) NULL,
    CONSTRAINT [PK_TransformStatistic] PRIMARY KEY CLUSTERED ([TransformStatisticMapID] ASC)
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [SystemLog].[TransformLog]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
CREATE TABLE [SystemLog].[TransformLog] (
    [TransformLogID] SMALLINT      IDENTITY (1, 1) NOT NULL,
    [TransformID]    VARCHAR (200) NOT NULL,
    [TransformName]  VARCHAR (255) NOT NULL,
    [TaskLogID]      SMALLINT      NOT NULL,
    CONSTRAINT [PK_ComponentLog] PRIMARY KEY CLUSTERED ([TransformLogID] ASC)
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [SystemLog].[TaskLog]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
CREATE TABLE [SystemLog].[TaskLog] (
    [TaskLogID]    SMALLINT         IDENTITY (1, 1) NOT NULL,
    [TaskID]       UNIQUEIDENTIFIER NOT NULL,
    [TaskName]     VARCHAR (255)    NOT NULL,
    [PackageLogID] SMALLINT         NOT NULL,
    CONSTRAINT [PK_TaskLog] PRIMARY KEY CLUSTERED ([TaskLogID] ASC)
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [SystemLog].[SystemConfigurations]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
CREATE TABLE [SystemLog].[SystemConfigurations] (
    [ConfigurationFilter] NVARCHAR (100) NOT NULL,
    [ConfiguredValue]     NVARCHAR (255) NOT NULL,
    [PackagePath]         NVARCHAR (255) NOT NULL,
    [ConfiguredValueType] NVARCHAR (20)  NOT NULL,
    CONSTRAINT [PK_SystemConfigurations] PRIMARY KEY CLUSTERED ([ConfigurationFilter] ASC, [ConfiguredValue] ASC)
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [SystemLog].[SystemConfigurations].[IX_SystemConfigurations]...';


GO
CREATE NONCLUSTERED INDEX [IX_SystemConfigurations]
    ON [SystemLog].[SystemConfigurations]([ConfigurationFilter] ASC);


GO
PRINT N'Creating [SystemLog].[Status]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
CREATE TABLE [SystemLog].[Status] (
    [StatusID]   TINYINT      NOT NULL,
    [StatusName] VARCHAR (25) NOT NULL,
    CONSTRAINT [PK_Status] PRIMARY KEY CLUSTERED ([StatusID] ASC)
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [SystemLog].[ProcessTaskTransformLog]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
CREATE TABLE [SystemLog].[ProcessTaskTransformLog] (
    [ProcessTaskComponentLogID] INT              IDENTITY (1, 1) NOT NULL,
    [ExecutionID]               UNIQUEIDENTIFIER NOT NULL,
    [StatisticValue]            BIGINT           NULL,
    [PackageStartDate]          DATETIME         NULL,
    [PackageEndDate]            DATETIME         NULL,
    [TransformStatisticID]      TINYINT          NULL,
    [LoadID]                    INT              NULL,
    [StatusID]                  TINYINT          NULL,
    [PackageLogID]              SMALLINT         NULL,
    [TaskLogID]                 SMALLINT         NULL,
    [TransformLogID]            SMALLINT         NULL,
    [TaskStartDate]             DATETIME         NULL,
    [TaskEndDate]               DATETIME         NULL,
    [TransformStartDate]        DATETIME         NULL,
    [TransformEndDate]          DATETIME         NULL,
    CONSTRAINT [PK_ProcessTaskComponentLog] PRIMARY KEY CLUSTERED ([ProcessTaskComponentLogID] ASC)
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [SystemLog].[PackageLog]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
CREATE TABLE [SystemLog].[PackageLog] (
    [PackageLogID]   SMALLINT         IDENTITY (1, 1) NOT NULL,
    [PackageName]    VARCHAR (255)    NOT NULL,
    [PackageGUID]    UNIQUEIDENTIFIER NOT NULL,
    [VersionBuild]   SMALLINT         NOT NULL,
    [VersionMajor]   SMALLINT         NOT NULL,
    [VersionMinor]   SMALLINT         NOT NULL,
    [VersionComment] VARCHAR (1000)   NULL,
    CONSTRAINT [PK_PackageLog] PRIMARY KEY CLUSTERED ([PackageLogID] ASC)
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [SystemLog].[MessageLog]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
CREATE TABLE [SystemLog].[MessageLog] (
    [CycleID]           INT            NULL,
    [LoadID]            INT            NULL,
    [InformationTypeID] TINYINT        NOT NULL,
    [Message]           VARCHAR (4000) NOT NULL,
    [PackageLogID]      SMALLINT       NULL,
    [TaskLogID]         SMALLINT       NULL,
    [Code]              VARCHAR (50)   NOT NULL,
    [ErrorDate]         SMALLDATETIME  NOT NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [SystemLog].[LoadLog]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
CREATE TABLE [SystemLog].[LoadLog] (
    [LoadID]        INT           IDENTITY (1, 1) NOT NULL,
    [CycleID]       INT           NOT NULL,
    [StartDate]     SMALLDATETIME NOT NULL,
    [EndDate]       SMALLDATETIME NULL,
    [LoadCode]      VARCHAR (200) NOT NULL,
    [LoadDate]      SMALLDATETIME NOT NULL,
    [StatusID]      TINYINT       NOT NULL,
    [EnvironmentID] TINYINT       NOT NULL,
    [BusSubjectID]  TINYINT       NOT NULL,
    CONSTRAINT [PK_LoadLog] PRIMARY KEY CLUSTERED ([LoadID] ASC)
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [SystemLog].[InformationType]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
CREATE TABLE [SystemLog].[InformationType] (
    [InformationTypeID]   TINYINT       NOT NULL,
    [InformationTypeName] VARCHAR (60)  NOT NULL,
    [InformationTypeDesc] VARCHAR (255) NULL,
    CONSTRAINT [PK_InformationType] PRIMARY KEY CLUSTERED ([InformationTypeID] ASC)
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[ApplicationGlobalConfigurations]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
CREATE TABLE [dbo].[ApplicationGlobalConfigurations] (
    [ConfigurationID]     INT            IDENTITY (1, 1) NOT NULL,
    [ConfigurationFilter] NVARCHAR (255) NOT NULL,
    [ConfiguredValue]     NVARCHAR (255) NULL,
    [PackagePath]         NVARCHAR (255) NOT NULL,
    [ConfiguredValueType] NVARCHAR (20)  NOT NULL,
    CONSTRAINT [PK_ApplicationGlobalConfigurations] PRIMARY KEY CLUSTERED ([ConfigurationID] ASC)
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[ApplicationRejects]...';


GO
CREATE TABLE [dbo].[ApplicationRejects] (
    [Code]              VARCHAR (100)  NOT NULL,
    [Description]       VARCHAR (4000) NULL,
    [InformationTypeID] TINYINT        NOT NULL
);


GO
PRINT N'Creating [SystemLog].[DF_LoadLog_LoadDate]...';


GO
ALTER TABLE [SystemLog].[LoadLog]
    ADD CONSTRAINT [DF_LoadLog_LoadDate] DEFAULT (getdate()) FOR [LoadDate];


GO
PRINT N'Creating [DW].[DimAddress_FactOrders_FK1]...';


GO
ALTER TABLE [DW].[FactOrders]
    ADD CONSTRAINT [DimAddress_FactOrders_FK1] FOREIGN KEY ([IDBillingAddress]) REFERENCES [DW].[DimAddress] ([IDAddress]);


GO
PRINT N'Creating [DW].[DimAddress_FactOrders_FK2]...';


GO
ALTER TABLE [DW].[FactOrders]
    ADD CONSTRAINT [DimAddress_FactOrders_FK2] FOREIGN KEY ([IDShippingAddress]) REFERENCES [DW].[DimAddress] ([IDAddress]);


GO
PRINT N'Creating [DW].[DimCustomer_FactOrders_FK1]...';


GO
ALTER TABLE [DW].[FactOrders]
    ADD CONSTRAINT [DimCustomer_FactOrders_FK1] FOREIGN KEY ([IDCustomer]) REFERENCES [DW].[DimCustomer] ([IDCustomer]);


GO
PRINT N'Creating [DW].[DimOrderProvenance_FactOrders_FK1]...';


GO
ALTER TABLE [DW].[FactOrders]
    ADD CONSTRAINT [DimOrderProvenance_FactOrders_FK1] FOREIGN KEY ([IDOrderProvenance]) REFERENCES [DW].[DimOrderProvenance] ([IDOrderProvenance]);


GO
PRINT N'Creating [DW].[DimProduct_FactOrders_FK1]...';


GO
ALTER TABLE [DW].[FactOrders]
    ADD CONSTRAINT [DimProduct_FactOrders_FK1] FOREIGN KEY ([IDProduct]) REFERENCES [DW].[DimProduct] ([IDProduct]);


GO
PRINT N'Creating [DW].[DimTime_FactOrders_FK1]...';


GO
ALTER TABLE [DW].[FactOrders]
    ADD CONSTRAINT [DimTime_FactOrders_FK1] FOREIGN KEY ([IDOrderDate]) REFERENCES [DW].[DimTime] ([IDTime]);


GO
PRINT N'Creating [DW].[DimTime_FactOrders_FK2]...';


GO
ALTER TABLE [DW].[FactOrders]
    ADD CONSTRAINT [DimTime_FactOrders_FK2] FOREIGN KEY ([IDShipDate]) REFERENCES [DW].[DimTime] ([IDTime]);


GO
PRINT N'Creating [DW].[DimTime_FactOrders_FK3]...';


GO
ALTER TABLE [DW].[FactOrders]
    ADD CONSTRAINT [DimTime_FactOrders_FK3] FOREIGN KEY ([IDDueDate]) REFERENCES [DW].[DimTime] ([IDTime]);


GO
PRINT N'Creating [SystemLog].[FK_LoadCycle_LoadApplication]...';


GO
ALTER TABLE [SystemLog].[CycleLog]
    ADD CONSTRAINT [FK_LoadCycle_LoadApplication] FOREIGN KEY ([ApplicationID]) REFERENCES [SystemLog].[Application] ([ApplicationID]);


GO
PRINT N'Creating [SystemLog].[FK_LoadCycle_Status]...';


GO
ALTER TABLE [SystemLog].[CycleLog]
    ADD CONSTRAINT [FK_LoadCycle_Status] FOREIGN KEY ([StatusID]) REFERENCES [SystemLog].[Status] ([StatusID]);


GO
PRINT N'Creating [SystemLog].[FK_ComponentLog_TaskLog]...';


GO
ALTER TABLE [SystemLog].[TransformLog]
    ADD CONSTRAINT [FK_ComponentLog_TaskLog] FOREIGN KEY ([TaskLogID]) REFERENCES [SystemLog].[TaskLog] ([TaskLogID]);


GO
PRINT N'Creating [SystemLog].[FK_TaskLog_PackageLog]...';


GO
ALTER TABLE [SystemLog].[TaskLog]
    ADD CONSTRAINT [FK_TaskLog_PackageLog] FOREIGN KEY ([PackageLogID]) REFERENCES [SystemLog].[PackageLog] ([PackageLogID]);


GO
PRINT N'Creating [SystemLog].[FK_ProcessTaskComponentLog_LoadLog]...';


GO
ALTER TABLE [SystemLog].[ProcessTaskTransformLog]
    ADD CONSTRAINT [FK_ProcessTaskComponentLog_LoadLog] FOREIGN KEY ([LoadID]) REFERENCES [SystemLog].[LoadLog] ([LoadID]);


GO
PRINT N'Creating [SystemLog].[FK_ProcessTaskComponentLog_PackageLog]...';


GO
ALTER TABLE [SystemLog].[ProcessTaskTransformLog]
    ADD CONSTRAINT [FK_ProcessTaskComponentLog_PackageLog] FOREIGN KEY ([PackageLogID]) REFERENCES [SystemLog].[PackageLog] ([PackageLogID]);


GO
PRINT N'Creating [SystemLog].[FK_ProcessTaskComponentLog_Statistic]...';


GO
ALTER TABLE [SystemLog].[ProcessTaskTransformLog]
    ADD CONSTRAINT [FK_ProcessTaskComponentLog_Statistic] FOREIGN KEY ([TransformStatisticID]) REFERENCES [SystemLog].[TransformStatisticMap] ([TransformStatisticMapID]);


GO
PRINT N'Creating [SystemLog].[FK_ProcessTaskComponentLog_Status]...';


GO
ALTER TABLE [SystemLog].[ProcessTaskTransformLog]
    ADD CONSTRAINT [FK_ProcessTaskComponentLog_Status] FOREIGN KEY ([StatusID]) REFERENCES [SystemLog].[Status] ([StatusID]);


GO
PRINT N'Creating [SystemLog].[FK_ProcessTaskComponentLog_TaskLog]...';


GO
ALTER TABLE [SystemLog].[ProcessTaskTransformLog]
    ADD CONSTRAINT [FK_ProcessTaskComponentLog_TaskLog] FOREIGN KEY ([TaskLogID]) REFERENCES [SystemLog].[TaskLog] ([TaskLogID]);


GO
PRINT N'Creating [SystemLog].[FK_ProcessTaskComponentLog_TransformLog]...';


GO
ALTER TABLE [SystemLog].[ProcessTaskTransformLog]
    ADD CONSTRAINT [FK_ProcessTaskComponentLog_TransformLog] FOREIGN KEY ([TransformLogID]) REFERENCES [SystemLog].[TransformLog] ([TransformLogID]);


GO
PRINT N'Creating [SystemLog].[FK_MessageLog_CycleLog]...';


GO
ALTER TABLE [SystemLog].[MessageLog]
    ADD CONSTRAINT [FK_MessageLog_CycleLog] FOREIGN KEY ([CycleID]) REFERENCES [SystemLog].[CycleLog] ([CycleID]);


GO
PRINT N'Creating [SystemLog].[FK_MessageLog_InformationType]...';


GO
ALTER TABLE [SystemLog].[MessageLog]
    ADD CONSTRAINT [FK_MessageLog_InformationType] FOREIGN KEY ([InformationTypeID]) REFERENCES [SystemLog].[InformationType] ([InformationTypeID]);


GO
PRINT N'Creating [SystemLog].[FK_MessageLog_LoadLog]...';


GO
ALTER TABLE [SystemLog].[MessageLog]
    ADD CONSTRAINT [FK_MessageLog_LoadLog] FOREIGN KEY ([LoadID]) REFERENCES [SystemLog].[LoadLog] ([LoadID]);


GO
PRINT N'Creating [SystemLog].[FK_LoadLog_Environment]...';


GO
ALTER TABLE [SystemLog].[LoadLog]
    ADD CONSTRAINT [FK_LoadLog_Environment] FOREIGN KEY ([BusSubjectID]) REFERENCES [SystemLog].[BusSubjectArea] ([BusSubjectID]);


GO
PRINT N'Creating [SystemLog].[FK_LoadLog_LoadCycle]...';


GO
ALTER TABLE [SystemLog].[LoadLog]
    ADD CONSTRAINT [FK_LoadLog_LoadCycle] FOREIGN KEY ([CycleID]) REFERENCES [SystemLog].[CycleLog] ([CycleID]);


GO
PRINT N'Creating [SystemLog].[FK_LoadLog_Status]...';


GO
ALTER TABLE [SystemLog].[LoadLog]
    ADD CONSTRAINT [FK_LoadLog_Status] FOREIGN KEY ([StatusID]) REFERENCES [SystemLog].[Status] ([StatusID]);


GO
PRINT N'Creating [SystemLog].[GetStatusTypeID]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE FUNCTION [SystemLog].[GetStatusTypeID]
(@STATUSNAME VARCHAR (25))
RETURNS TINYINT
AS
BEGIN
	declare @Return TINYINT

	SELECT @Return = StatusID
	FROM SystemLog.Status
	WHERE StatusName = @STATUSNAME;
	
    RETURN ISNULL(@return, 0)
END
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [SystemLog].[GetInformationTypeID]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE FUNCTION [SystemLog].[GetInformationTypeID]
(@INFORMATIONTYPENAME VARCHAR (25))
RETURNS TINYINT
AS
BEGIN
	declare @Return TINYINT

	SELECT @Return = InformationTypeID
	FROM SystemLog.InformationType
	WHERE InformationTypeName = @INFORMATIONTYPENAME;
	
    RETURN ISNULL(@return, 0)
END
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[ParsePipeline]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE FUNCTION [dbo].[ParsePipeline]
(@message VARCHAR (8000), @which INT)
RETURNS VARCHAR (200)
AS
begin
	--@which defines which value is desired
	-- 1= PathID
	-- 2= declare PathIDName
	-- 3= declare ComponentID
	-- 4= declare ComponentIDName
	-- 5= declare InputID
	-- 6= declare InputIDName
	-- 7= declare rowssent

	declare @sourcemessage varchar(600)	
	declare @where as integer
	declare @mycounter integer

	If @which < 1 or @which > 7 return null
	set @mycounter=0
	--catch older versions of the messages that lacked the extra parameters
	if patindex('%:  :%', @message) = 0 return null
	
	--chop the initial wordy stuff out
	set @sourcemessage = right(@message, len(@message) - patindex('%:  :%', @message) - 3)

	--loop through occurances of : until we get to the desired one
	set @where = 99
	while @where <> 0 begin
		set @mycounter = @mycounter+1
		set @where = patindex('%:%',@sourcemessage)
		If @mycounter = 7 return @sourcemessage
		if @mycounter = @which return(left(@sourcemessage, @where - 1))
		set	@sourcemessage = right(@sourcemessage, (len(@sourcemessage) - @where))	
	end --while
	
	--should not execute this but a return is required as the last statement
	return @sourcemessage
end
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[DF_ApplicationRejects_InformationTypeID]...';


GO
ALTER TABLE [dbo].[ApplicationRejects]
    ADD CONSTRAINT [DF_ApplicationRejects_InformationTypeID] DEFAULT ([SystemLog].[GetInformationTypeID]('Error')) FOR [InformationTypeID];


GO
PRINT N'Creating [Cube].[FactOrder_VW]...';


GO
create view Cube.FactOrder_VW
AS 
SELECT [IDOrderDate]
      ,[IDShipDate]
      ,[IDDueDate]
      ,[IDProduct]
      ,[IDCustomer]
      ,[IDBillingAddress]
      ,[IDShippingAddress]
      ,[IDOrderProvenance]
      ,[OrderQy]
      ,[UnitPrice]
      ,[Discount]
      ,[TaxAmount]
      ,[Freight]
      ,[IDSalesOrder]
      ,[IDPurchaseOrder]

      ,[LoadID]
  FROM [DW].[FactOrdersBig] f
  INNER JOIN [Cube].[DimPurchaseOrder] po ON po.[PurchaseOrder] = f.[PurchaseOrderNumber]
  INNER JOIN [Cube].[DimSalesOrder] so ON so.[SalesOrderNumber] = f.[SalesOrderNumber]
GO
PRINT N'Creating [Cube].[DimTime]...';


GO
Create view Cube.DimTime as 
SELECT        IDTime, DateOfDay, DayName, DayNbOfTheWeek, DayNbOfTheMonth, DayNbOfTheYear, MonthName, MonthNb, WeekNbOfTheMonth, QuaterNb, YearNb, 
                         IsWeekDayFlag, IsHolidayFlag, 'Quarter ' + CAST(QuaterNb AS varchar(1)) AS QuarterName, YearNb * 100 + QuaterNb AS QuaterYear, YearNb * 100 + MonthNb AS MonthYear
FROM            DW.DimTime
GO
PRINT N'Creating [Cube].[FactOrders]...';


GO
create view [Cube].[FactOrders]
AS 
SELECT [IDOrderDate]
      ,[IDShipDate]
      ,[IDDueDate]
      ,[IDProduct]
      ,[IDCustomer]
      ,[IDBillingAddress]
      ,[IDShippingAddress]
      ,[IDOrderProvenance]
      ,[OrderQy]
      ,[UnitPrice]
      ,[Discount]
      ,[TaxAmount]
      ,[Freight]
  FROM [DW].[FactOrders]
GO
PRINT N'Creating [SystemLog].[v_Audit_Load_log]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO

CREATE VIEW [SystemLog].[v_Audit_Load_log]
AS
SELECT     l.LoadID, pack.PackageName, task.TaskName, tr.TransformName, ts.[TransformStatisticMapName], ptt.StatisticValue, s.StatusName, l.StartDate AS LoadLogStartDate, 
                      l.EndDate AS LoadLogEndDate, ptt.PackageStartDate, ptt.PackageEndDate, ptt.TaskStartDate, ptt.TaskEndDate, ptt.TransformStartDate, ptt.TransformEndDate
FROM         SystemLog.LoadLog AS l INNER JOIN
                      SystemLog.ProcessTaskTransformLog AS ptt ON l.LoadID = ptt.LoadID INNER JOIN
                      SystemLog.[TransformStatisticMap] AS ts ON ptt.TransformStatisticID = ts.[TransformStatisticMapID] INNER JOIN
                      SystemLog.Status AS s ON l.StatusID = s.StatusID INNER JOIN
                      SystemLog.TransformLog AS tr ON ptt.TransformLogID = tr.TransformLogID INNER JOIN
                      SystemLog.PackageLog AS pack ON ptt.PackageLogID = pack.PackageLogID INNER JOIN
                      SystemLog.TaskLog AS task ON ptt.TaskLogID = task.TaskLogID AND tr.TaskLogID = task.TaskLogID AND pack.PackageLogID = task.PackageLogID;
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [SystemLog].[v_Audit_Cycle_log]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE VIEW [SystemLog].[v_Audit_Cycle_log]
AS
SELECT                appl.ApplicationName, cyc.CycleID, cyc.StartDate AS CycleStartDate,cyc.EndDate AS CycleEndDate,
                      l.LoadID, l.StartDate as LoadStartDate, l.EndDate AS LoadEndDate,
                      pack.PackageName, task.TaskName, tr.TransformName, ts.[TransformStatisticMapName], ptt.StatisticValue, s.StatusName, l.StartDate AS LoadLogStartDate, 
                      l.EndDate AS LoadLogEndDate, ptt.PackageStartDate, ptt.PackageEndDate, ptt.TaskStartDate, ptt.TaskEndDate, ptt.TransformStartDate, ptt.TransformEndDate
FROM                  SystemLog.Application AS Appl inner join 
                      SystemLog.CycleLog AS cyc on Appl.ApplicationID = cyc.ApplicationID inner join 
                      SystemLog.LoadLog AS l  on cyc.CycleID = l.CycleID INNER JOIN
                      SystemLog.ProcessTaskTransformLog AS ptt ON l.LoadID = ptt.LoadID INNER JOIN
                      SystemLog.[TransformStatisticMap] AS ts ON ptt.TransformStatisticID = ts.[TransformStatisticMapID] INNER JOIN
                      SystemLog.Status AS s ON ptt.StatusID = s.StatusID INNER JOIN
                      SystemLog.TransformLog AS tr ON ptt.TransformLogID = tr.TransformLogID INNER JOIN
                      SystemLog.PackageLog AS pack ON ptt.PackageLogID = pack.PackageLogID INNER JOIN
                      SystemLog.TaskLog AS task ON ptt.TaskLogID = task.TaskLogID AND tr.TaskLogID = task.TaskLogID AND pack.PackageLogID = task.PackageLogID;
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [SystemLog].[ProcessTaskTransformLogUps]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE PROCEDURE [SystemLog].[ProcessTaskTransformLogUps]
@LoadID INT, @ExecutionID UNIQUEIDENTIFIER, @VersionBuild SMALLINT, @VersionMajor SMALLINT, @VersionMinor SMALLINT, @VersionComment VARCHAR (1000)
AS
BEGIN
 -- DECLARE @sysssisdtsStats TABLE
 -- (
 --   ExecutionID uniqueidentifier,
 --   Computer varchar(128),
 --   Operator varchar(128),
 --   PackageID uniqueidentifier,
 --   PackageName varchar(1024),
 --   PackageStartDate datetime,
 --   PackageEndDate datetime,
 --   TaskID uniqueidentifier,
 --   TaskName varchar(1024),
 --   TransformID VARCHAR (200),
 --   TransformStatisticID tinyint,
 --   TransformStatisticName varchar(60),
 --   TransformName varchar(1024),
 --   BuffersToInputCount int,
 --   RowsSent int,
 --   TransformStartDate datetime,
 --   TransformEndDate datetime,
 --   SecondsElapsed int
 -- )
 -- BEGIN TRY  
 --   INSERT INTO @sysssisdtsStats 
 --   SELECT 
 --     StartLog.executionid, 
 --     StartLog.computer, 
 --     StartLog.operator,
 --     StartLog.sourceid AS PackageID, 
 --     StartLog.source AS PackageName, 
 --     StartLog.starttime AS PackageStartDate,
 --     EndLog.endtime AS PackageEndDate,
 --     l.TaskID, 
 --     l.TaskName AS TaskName, 
 --     l.SSIS_PATH_ID as TransformID,
 --     ts.[TransformStatisticMapID],
 --     ts.[TransformStatisticMapName], 
 --     l.SSIS_PATH_Name AS TransformName,
 --     COUNT(l.SSIS_PATH_ID) AS BuffersToInputCount, 
 --     SUM(l.RowSent) AS RowsSent, 
 --     MIN(l.TransformStartDate ) AS TransformStartDate, 
 --     MAX(l.TransformEndDate) AS TransformEndDate, 
 --     DATEDIFF(s, MIN(l.TransformStartDate), MAX(l.TransformEndDate)) AS SecondsElapsed  
 --   FROM dbo.sysssislog AS StartLog 
 --        LEFT OUTER JOIN dbo.sysssislog AS EndLog ON StartLog.executionid = EndLog.executionid AND StartLog.source = EndLog.source AND EndLog.event = 'PackageEnd'
 --        LEFT OUTER JOIN SystemLog.v_Task_ComponentLogDtl_Statistics AS l ON l.ExecutionID = StartLog.executionid
 --        INNER JOIN SystemLog.[TransformStatisticMap] AS ts ON UPPER(l.SSIS_PATH_Name) LIKE '%' + UPPER(ts.[TransformStatisticMapObjectLinkCode]) + '%'
 --   WHERE (StartLog.event = 'PackageStart')
 --     AND (StartLog.ExecutionID = @ExecutionID)
 --   GROUP BY
 --     StartLog.executionid, 
 --     StartLog.computer, 
 --     StartLog.operator,
 --     StartLog.sourceid, 
 --     StartLog.source, 
 --     StartLog.starttime,
 --     EndLog.endtime,
 --     l.TaskName, 
 --     l.SSIS_PATH_Name, 
 --     l.ExecutionID, 
 --     ts.[TransformStatisticMapID],
 --     ts.[TransformStatisticMapName],
 --     l.TaskID,
 --     l.SSIS_PATH_ID
 --   UNION ALL
 --   SELECT 
 --     StartLog.executionid, 
 --     StartLog.computer, 
 --     StartLog.operator,
 --     StartLog.sourceid AS PackageID, 
 --     StartLog.source AS PackageName, 
 --     StartLog.starttime AS PackageStartDate,
 --     EndLog.endtime AS PackageEndDate,
 --     l.TaskID, 
 --     l.TaskName AS TaskName,
 --     l.TransformID as TransformID,
 --     ts.[TransformStatisticMapID],
 --     ts.[TransformStatisticMapName], 
 --     l.TransformName AS TransformName,
 --     COUNT(l.SSIS_PATH_ID) AS BuffersToInputCount, 
 --     SUM(l.RowSent) AS RowsSent, 
 --     MIN(l.TransformStartDate ) AS TransformStartDate, 
 --     MAX(l.TransformEndDate) AS TransformEndDate, 
 --     DATEDIFF(s, MIN(l.TransformStartDate), MAX(l.TransformEndDate)) AS SecondsElapsed  
 --   FROM dbo.sysssislog AS StartLog 
 --        LEFT OUTER JOIN dbo.sysssislog AS EndLog ON StartLog.executionid = EndLog.executionid AND StartLog.source = EndLog.source AND EndLog.event = 'PackageEnd'
 --        LEFT OUTER JOIN SystemLog.v_Task_ComponentLogDtl_Statistics AS l ON l.ExecutionID = StartLog.executionid
 --        INNER JOIN SystemLog.[TransformStatisticMap] AS ts ON UPPER(l.TransformName) LIKE '%' + UPPER(ts.[TransformStatisticMapObjectLinkCode]) + '%'
 --   WHERE (StartLog.event = 'PackageStart')
 --     AND (StartLog.ExecutionID = @ExecutionID)
 --   GROUP BY
 --     StartLog.executionid, 
 --     StartLog.computer, 
 --     StartLog.operator,
 --     StartLog.sourceid, 
 --     StartLog.source, 
 --     StartLog.starttime,
 --     EndLog.endtime,
 --     l.TaskName, 
 --     l.TransformName, 
 --     l.ExecutionID, 
 --     ts.[TransformStatisticMapID],
 --     ts.[TransformStatisticMapName],
 --     l.TaskID,
 --     l.TransformID
      
 -- MERGE INTO SystemLog.PackageLog trg
 -- USING (
 --         SELECT DISTINCT PackageID, PackageName
 --         FROM @sysssisdtsStats
 --       ) src ON (trg.PackageGUID = src.PackageID
 --                 AND trg.VersionBuild = @VersionBuild
 --                 AND trg.VersionMajor = @VersionMajor
 --                 AND trg.VersionMinor = @VersionMinor)
 -- WHEN MATCHED THEN
 --   UPDATE SET PackageName = src.PackageName, VersionComment = @VersionComment
 -- WHEN NOT MATCHED THEN
 --   INSERT VALUES (src.PackageName, src.PackageID, @VersionBuild, @VersionMajor, @VersionMinor, @VersionComment);

 -- MERGE INTO SystemLog.TaskLog trg
 -- USING (
 --         SELECT DISTINCT t2.PackageLogID, t1.TaskID, t1.TaskName
 --         FROM @sysssisdtsStats t1
 --              JOIN SystemLog.PackageLog t2 ON (t1.PackageID = t2.PackageGUID
 --                                               AND t2.VersionBuild = @VersionBuild
 --                                               AND t2.VersionMajor = @VersionMajor
 --                                               AND t2.VersionMinor = @VersionMinor)
 --       ) src ON (trg.TaskId = src.TaskID AND trg.PackageLogID = src.PackageLogID)
 -- WHEN MATCHED THEN
 --   UPDATE SET TaskName = src.TaskName
 -- WHEN NOT MATCHED THEN
 --   INSERT VALUES (src.TaskID, src.TaskName, src.PackageLogID);


 -- MERGE INTO SystemLog.TransformLog trg
 -- USING (
 --         SELECT DISTINCT t2.TaskLogID, t1.TransformID, t1.TransformName
 --         FROM @sysssisdtsStats t1
 --             JOIN SystemLog.PackageLog t3 ON (t1.PackageID = t3.PackageGUID
 --                                               AND t3.VersionBuild = @VersionBuild
 --                                               AND t3.VersionMajor = @VersionMajor
 --                                               AND t3.VersionMinor = @VersionMinor)
 --            JOIN SystemLog.TaskLog t2 ON (t1.TaskID = t2.TaskID AND t2.PackageLogID = t3.PackageLogID )
 --       ) src ON (trg.TransformID = src.TransformID AND trg.TaskLogID = src.TaskLogID)
 -- WHEN MATCHED THEN
 --   UPDATE SET TransformName = src.TransformName
 -- WHEN NOT MATCHED THEN
 --   INSERT VALUES (CAST(src.TransformID AS VARCHAR(200)), src.TransformName, src.TaskLogID);
    

 -- INSERT INTO [SystemLog].[ProcessTaskTransformLog]
 --            ([ExecutionID]
 --            ,[StatisticValue]
 --            ,[PackageStartDate]
 --            ,[PackageEndDate]
 --            ,[TransformStatisticID]
 --            ,[LoadID]
 --            ,[StatusID]
 --            ,[PackageLogID]
 --            ,[TaskLogID]
 --            ,[TransformLogID]
 --            ,[TaskStartDate]
 --            ,[TaskEndDate]
 --            ,[TransformStartDate]
 --            ,[TransformEndDate])
 -- SELECT t.ExecutionID, t.RowsSent, t.PackageStartDate, ISNULL(t.PackageEndDate, GetDate()), t.TransformStatisticID,
 -- @LoadID, t2.StatusID, t3.PackageLogID, t4.TaskLogID, t5.TransformLogID, t.TransformStartDate,
 -- t.TransformEndDate, t.TransformStartDate, t.TransformEndDate
 -- FROM @sysssisdtsStats t
 --      JOIN SystemLog.LoadLog t2 ON (@LoadID = t2.LoadID)
 --      JOIN SystemLog.PackageLog t3 ON (t.PackageID = t3.PackageGUID
 --                                      AND t3.VersionBuild = @VersionBuild
	--								   AND t3.VersionMajor = @VersionMajor
	--								   AND t3.VersionMinor = @VersionMinor)
 --      JOIN SystemLog.TaskLog t4 ON (t.TaskID = t4.TaskID AND t4.PackageLogID = t3.PackageLogID)
 --      JOIN SystemLog.TransformLog t5 ON (t.TransformID = t5.TransformID AND t5.TaskLogID = t4.TaskLogID)
 -- END TRY
 -- BEGIN CATCH
 --   INSERT INTO SystemLog.MessageLog([LoadID], [InformationTypeID], [Message], [PackageLogID], [TaskLogID], [Code], [ErrorDate], [CycleID])
 --   SELECT 
 --     ISNULL(@LoadID, 0) AS LoadID,
 --     inf.InformationTypeID, 
 --     (
 --       SELECT 
	--	      ERROR_NUMBER() AS "@Number",
	--	      ERROR_STATE() AS "@State",
	--	      ERROR_SEVERITY() AS "@Severity",
	--	      ERROR_MESSAGE() AS "Message",
	--	      ERROR_LINE() AS "Procedure/@Line",
	--	      ERROR_PROCEDURE() AS "Procedure"
	--	    FOR XML PATH('Error')
	--	  ) AS [Message],
	--	  0 AS PackageLogID,
	--	  0 AS TaskLogID,
	--	  ERROR_NUMBER() AS Code,
	--	  GETDATE() AS ErrorDate,
	--	  ISNULL(ld.CycleID, 0) AS CycleID
 --   FROM [SystemLog].[InformationType] inf
 --        LEFT JOIN SystemLog.LoadLog ld ON ld.LoadID = @LoadID
 --   WHERE [InformationTypeName] = 'Error'
    
	--DECLARE @ERRORMESSAGE VARCHAR(200);

	--SELECT @ERRORMESSAGE = ERROR_MESSAGE();

	--RAISERROR('Error processing statistics - %s', 16, 1, @ERRORMESSAGE);
 -- END CATCH    
 select 1   
END
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [SystemLog].[PackageLogUps]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE PROCEDURE [SystemLog].[PackageLogUps]
@PackageName VARCHAR (255), @PackageGuid UNIQUEIDENTIFIER, @VersionBuild SMALLINT, @VersionMajor SMALLINT, @VersionMinor SMALLINT, @VersionComment VARCHAR (1000), @PackageLogID INT OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	declare @tbl table (ID int);
	SET @PackageLogID = -1;
	begin try
		update [SystemLog].PackageLog
		set PackageName = @PackageName,
		    VersionComment = @VersionComment
		output inserted.PackageLogID into @tbl
		WHERE PackageGUID = @PackageGuid
		  and  VersionBuild = @VersionBuild
		  and VersionMajor = @VersionMajor
		  and VersionMinor = @VersionMinor;
	      
		IF (Select COUNT(1) from @tbl) > 1 
		  raiserror('More than one packagelog row updated',10,127)
		  
		if not exists( select 1 from @tbl) 
		  INSERT INTO [SystemLog].[PackageLog]
			   ([PackageName]
			   ,[PackageGUID]
			   ,[VersionBuild]
			   ,[VersionMajor]
			   ,[VersionMinor]
			   ,[VersionComment])
			   output inserted.PackageLogID into @tbl 
		 VALUES
			   (@PackageName, 
				@PackageGUID, 
				@VersionBuild, 
				@VersionMajor, 
				@VersionMinor, 
				@VersionComment);
	   select @PackageLogID =  ID
	   from @tbl;
	end try
	begin catch
	  SELECT
		ERROR_NUMBER() AS "@Number",
		ERROR_STATE() AS "@State",
		ERROR_SEVERITY() AS "@Severity",
		ERROR_MESSAGE() AS "Message",
		ERROR_LINE() AS "Procedure/@Line",
		ERROR_PROCEDURE() AS "Procedure"
		FOR XML PATH('Error');
	end catch            


  
END
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [SystemLog].[OpenLoad]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE PROCEDURE [SystemLog].[OpenLoad]
@PackageName VARCHAR (255), @PackageGuid UNIQUEIDENTIFIER, @VersionBuild SMALLINT, @VersionMajor SMALLINT, @VersionMinor SMALLINT, @VersionComment VARCHAR (1000), @CycleID INT, @EnvironmentName VARCHAR (100), @BusSubjectName VARCHAR (100), @LoadCode VARCHAR (200), @ReuseLoadID TINYINT
AS
DECLARE @EnvironmentID tinyint;
DECLARE @BusSubjectID tinyint;
DECLARE @PackageLogID int;
DECLARE @ExecutingLoadCount int;
DECLARE @CycleCount int;
DECLARE @LoadTbl TABLE ( LoadID int NOT NULL)

BEGIN TRY
  -- Get the ID for the Environment Name
  SELECT @EnvironmentID = l.EnvironmentID  
  FROM SystemLog.Environment  l
  WHERE UPPER(LTRIM(RTRIM(l.EnvironmentName ))) = UPPER(LTRIM(RTRIM(@EnvironmentName)))
    
  IF @EnvironmentID IS NULL 
    RAISERROR('No entry found in table SystemLog.Environment for environement name ''%s''',16, 1, @EnvironmentName);
  
  -- Get the ID for the Business Subject Name
  SELECT @BusSubjectID = l.BusSubjectID  
  FROM SystemLog.BusSubjectArea  l
  WHERE UPPER(LTRIM(RTRIM(l.BusSubjectName))) = UPPER(LTRIM(RTRIM(@BusSubjectName)))
    
  IF @BusSubjectID IS NULL 
    RAISERROR('No entry found in table SystemLog.BusSubjectArea for BusSubject name ''%s''',16, 1, @BusSubjectName);
  
  
  -- Get the ID for the Business Subject Name
  SELECT @CycleCount = COUNT(1)
  FROM SystemLog.CycleLog l
  WHERE l.CycleID = @CycleID;
    
  IF @CycleCount = 0
    RAISERROR('No entry found in table SystemLog.CycleLog for cycle name ''%i''',16, 1, @CycleID);
 
  --Lookup all loads for a given BusSubjectName, EnvironmentName, CycleID, StatusID 
  --and LoadDate which are executing
  SELECT @ExecutingLoadCount = COUNT(*)
  FROM SystemLog.LoadLog l
  WHERE l.BusSubjectID = @BusSubjectID
    AND l.CycleID = @CycleID
    AND l.EnvironmentID = @EnvironmentID
    AND l.LoadCode = @LoadCode
    AND l.StatusID = [SystemLog].[GetStatusTypeID]('Executing');
    
  -- Depending if an executing cycle already exists and or the @ReuseLoadID flag...
  IF @ExecutingLoadCount = 1 AND @ReuseLoadID = 1
    BEGIN
      UPDATE SystemLog.LoadLog
      SET StartDate = CAST(GetDate() AS SmallDateTime)
      OUTPUT inserted.CycleID
      INTO @LoadTbl
      WHERE BusSubjectID = @BusSubjectID
        AND CycleID = @CycleID
        AND EnvironmentID = @EnvironmentID
        AND LoadCode = @LoadCode
        AND StatusID = [SystemLog].[GetStatusTypeID]('Executing');
    END
    
  IF @ExecutingLoadCount = 1 AND @ReuseLoadID = 0
    BEGIN
      UPDATE SystemLog.LoadLog
      SET StatusID = [SystemLog].[GetStatusTypeID]('Failure'), EndDate = CAST(GETDATE() AS SmallDateTime)
      WHERE BusSubjectID = @BusSubjectID
        AND CycleID = @CycleID
        AND EnvironmentID = @EnvironmentID
        AND LoadCode = @LoadCode
        AND StatusID = [SystemLog].[GetStatusTypeID]('Executing');  
               
      INSERT INTO [SystemLog].[LoadLog] ([CycleID], [StartDate], [LoadCode], [LoadDate], [StatusID], [EnvironmentID], [BusSubjectID])
      OUTPUT inserted.LoadID
      INTO @LoadTbl
      VALUES( @CycleID, CAST(GETDATE() AS SmallDateTime), @LoadCode, CAST(GETDATE() AS SmallDateTime), [SystemLog].[GetStatusTypeID]('Executing'), @EnvironmentID, @BusSubjectID );      
    END    

  IF @ExecutingLoadCount = 0
    BEGIN
      INSERT INTO [SystemLog].[LoadLog] ([CycleID], [StartDate], [LoadCode], [LoadDate], [StatusID], [EnvironmentID], [BusSubjectID])
      OUTPUT inserted.LoadID
      INTO @LoadTbl
      VALUES( @CycleID, CAST(GETDATE() AS SmallDateTime), @LoadCode, CAST(GETDATE() AS SmallDateTime), [SystemLog].[GetStatusTypeID]('Executing'), @EnvironmentID, @BusSubjectID );      
    END  

    IF @ExecutingLoadCount > 1
      RAISERROR('More than one load currently executing for environment name ''%s'', business subject name ''%s'', load code ''%s'',  cycle id ''%i'' and status ''Executing''',16, 1, @BusSubjectName, @EnvironmentName, @LoadCode, @CycleID);
END TRY
BEGIN CATCH
  Exec [SystemLog].[PackageLogUps] 
    @PackageName, 
    @PackageGuid, 
    @VersionBuild, 
    @VersionMajor, 
    @VersionMinor, 
    @VersionComment,
    @PackageLogID OUTPUT

  INSERT INTO SystemLog.MessageLog([LoadID], [InformationTypeID], [Message], [PackageLogID], [TaskLogID], [Code], [ErrorDate], [CycleID])
  SELECT 
    0 AS LoadID,
    [SystemLog].[GetInformationTypeID]('Error'), 
    (
      SELECT 
	      ERROR_NUMBER() AS "@Number",
	      ERROR_STATE() AS "@State",
	      ERROR_SEVERITY() AS "@Severity",
	      ERROR_MESSAGE() AS "Message",
	      ERROR_LINE() AS "Procedure/@Line",
	      ERROR_PROCEDURE() AS "Procedure"
	    FOR XML PATH('Error')
	  ) AS [Message],
	  @PackageLogID AS PackageLogID,
	  0 AS TaskLogID,
	  ERROR_NUMBER() AS Code,
	  GETDATE() AS ErrorDate,
	  @CycleID AS CycleID;
  
  DECLARE @ERRORMESSAGE VARCHAR(200);
  
  SELECT @ERRORMESSAGE = ERROR_MESSAGE();
  
  INSERT INTO @LoadTbl (LoadID) Values(0);

  RAISERROR('Error opening load - %s', 16, 1, @ERRORMESSAGE);
END CATCH  

SELECT 
  ISNULL(s.LoadID, 0) AS LoadID,
  ISNULL(( 
    SELECT MAX(t.LoadID) AS PreviousLoadID
	FROM SystemLog.LoadLog t
	WHERE t.BusSubjectID = @BusSubjectID
	  AND t.LoadID <> s.LoadID
	  AND t.StatusID = [SystemLog].[GetStatusTypeID]('Success')
  ), 0) AS PreviousLoadID
FROM @LoadTbl s;
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [SystemLog].[OpenCycle]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE PROCEDURE [SystemLog].[OpenCycle]
@PackageName VARCHAR (255), @PackageGuid UNIQUEIDENTIFIER, @VersionBuild SMALLINT, @VersionMajor SMALLINT, @VersionMinor SMALLINT, @VersionComment VARCHAR (1000), @ApplicationName VARCHAR (255), @ReuseCycleID SMALLINT, @UserName VARCHAR (100)
AS
DECLARE @ApplicationID TINYINT;
DECLARE @PackageLogID int;
DECLARE @ExecutingCycleCount int;
DECLARE @CycleTbl TABLE ( CycleID int )

BEGIN TRY

  -- Get the ID for the Application Name
  SELECT @ApplicationID = l.ApplicationID 
  FROM SystemLog.[Application] l
  WHERE UPPER(LTRIM(RTRIM(l.ApplicationName))) = UPPER(LTRIM(RTRIM(@ApplicationName)))
    
  -- Verify that The status IDs have been properly SET
  IF @ApplicationID IS NULL 
    RAISERROR('No entry found in table SystemLog.LoadApplication for application name ''%s''',16, 1, @ApplicationName);
  
  -- Lookup all Cycles for a given ApplicationID which are executing
  SELECT @ExecutingCycleCount = COUNT(*)
  FROM SystemLog.CycleLog l
  WHERE l.ApplicationID = @ApplicationID 
    AND l.StatusID = [SystemLog].[GetStatusTypeID]('Executing');
    
  -- Depending if an executing cycle already exists and or the @ReuseCycleID flag...
  IF @ExecutingCycleCount = 1 AND @ReuseCycleID = 1
    BEGIN
      UPDATE SystemLog.CycleLog
      SET StartDate = GetDate()
      OUTPUT inserted.CycleID
      INTO @CycleTbl
      WHERE ApplicationID = @ApplicationID 
        AND StatusID = [SystemLog].[GetStatusTypeID]('Executing');
    END
    
  IF @ExecutingCycleCount = 1 AND @ReuseCycleID = 0
    BEGIN
      UPDATE SystemLog.CycleLog
      SET StatusID = [SystemLog].[GetStatusTypeID]('Failure'), EndDate = GETDATE()
      WHERE ApplicationID = @ApplicationID 
        AND StatusID = [SystemLog].[GetStatusTypeID]('Executing');
        
      INSERT INTO [SystemLog].[CycleLog] ([ApplicationID], [StartDate] ,[StatusID], [UserName])
      OUTPUT inserted.CycleID
      INTO @CycleTbl
      VALUES( @ApplicationID, GETDATE(), [SystemLog].[GetStatusTypeID]('Executing'), @UserName );      
    END    

  IF @ExecutingCycleCount = 0
    BEGIN
      INSERT INTO [SystemLog].[CycleLog] ([ApplicationID], [StartDate] ,[StatusID], [UserName])
      OUTPUT inserted.CycleID
      INTO @CycleTbl
      VALUES( @ApplicationID, GETDATE(), [SystemLog].[GetStatusTypeID]('Executing'), @UserName );      
    END  

    IF @ExecutingCycleCount > 1
      RAISERROR('More than one cycle currently executing for application ''%s''',16, 1, @ApplicationName);
END TRY
BEGIN CATCH
  /* Make sure the Meta data table PackageLog contains the information for this package */
  Exec [SystemLog].[PackageLogUps] 
    @PackageName, 
    @PackageGuid, 
    @VersionBuild, 
    @VersionMajor, 
    @VersionMinor, 
    @VersionComment,
    @PackageLogID OUTPUT

  /* Cycle could not be opened, insert an error message */
  INSERT INTO SystemLog.MessageLog([LoadID], [InformationTypeID], [Message], [PackageLogID], [TaskLogID], [Code], [ErrorDate], [CycleID])
  SELECT 
    0 AS LoadID,
    [SystemLog].[GetInformationTypeID]('Error'), 
    (
      SELECT 
	      ERROR_NUMBER() AS "@Number",
	      ERROR_STATE() AS "@State",
	      ERROR_SEVERITY() AS "@Severity",
	      ERROR_MESSAGE() AS "Message",
	      ERROR_LINE() AS "Procedure/@Line",
	      ERROR_PROCEDURE() AS "Procedure"
	    FOR XML PATH('Error')
	  ) AS [Message],
	  @PackageLogID AS PackageLogID,
	  0 AS TaskLogID,
	  ERROR_NUMBER() AS Code,
	  GETDATE() AS ErrorDate,
	  0 AS CycleID;

  DECLARE @ERRORMESSAGE VARCHAR(200);
  
  SELECT @ERRORMESSAGE = ERROR_MESSAGE();
  
  INSERT INTO @CycleTbl (CycleID) Values(0);
  
  RAISERROR('Error opening cycle - %s', 16, 1, @ERRORMESSAGE);	
END CATCH  

SELECT ISNULL(s.CycleID, 0) AS CycleID FROM @CycleTbl s;
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [SystemLog].[LogMessage]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE PROCEDURE [SystemLog].[LogMessage]
@PackageName VARCHAR (255), @PackageGuid UNIQUEIDENTIFIER, @VersionBuild SMALLINT, @VersionMajor SMALLINT, @VersionMinor SMALLINT, @VersionComment VARCHAR (1000), @ErrorCode INT, @ErrorMessage VARCHAR (4000), @LoadID INT, @CycleID INT, @MessageTypeToLog VARCHAR (60)
AS
DECLARE @PackageLogID SMALLINT;
DECLARE @LKPCycleID INT;

BEGIN TRY 
  /* If CycleID is 0 and loadId is provided, lookup the related cycleID */
  IF @CycleID = 0 AND @LoadID > 0
	  BEGIN
		SELECT @LKPCycleID = CycleID
		FROM SystemLog.LoadLog
		WHERE LoadID = @LoadID
	  END
	 
  ELSE
	  BEGIN
		SET @LKPCycleID = @CycleID
	  END

	  IF @LoadID = 0
	    SET @LoadID = NULL;
	  
 /* Make sure the Meta data table PackageLog contains the information for this package */
  Exec [SystemLog].[PackageLogUps] 
    @PackageName, 
    @PackageGuid, 
    @VersionBuild, 
    @VersionMajor, 
    @VersionMinor, 
    @VersionComment,
    @PackageLogID OUTPUT;    
   
   
   IF NOT EXISTS(SELECT TOP 1 1 FROM [SystemLog].[MessageLog] 
                  WHERE (ISNULL([CycleID], 0) = ISNULL(@CycleID, 0)
                    OR ISNULL([LoadID], 0) = ISNULL(@LoadID, 0))
					AND [Code] = CAST(@ErrorCode AS VARCHAR(50)))
   BEGIN
	  /* Insert the message */
	  INSERT INTO [SystemLog].MessageLog([LoadID], [InformationTypeID], [Message], [PackageLogID], [TaskLogID], [Code], [ErrorDate], [CycleID])
	  VALUES (@LoadID, [SystemLog].[GetInformationTypeID](@MessageTypeToLog), @ErrorMessage, @PackageLogID, 0, CAST(@ErrorCode AS VARCHAR(50)), CAST(GETDATE() AS SmallDateTime), @LKPCycleID) ;
   END
END TRY
BEGIN CATCH
  /* Make sure the Meta data table PackageLog contains the information for this package */
  Exec [SystemLog].[PackageLogUps] 
    @PackageName, 
    @PackageGuid, 
    @VersionBuild, 
    @VersionMajor, 
    @VersionMinor, 
    @VersionComment,
    @PackageLogID OUTPUT

  /* Message could not be inserted, insert an error message */
  INSERT INTO SystemLog.MessageLog([LoadID], [InformationTypeID], [Message], [PackageLogID], [TaskLogID], [Code], [ErrorDate], [CycleID])
  SELECT 
    @LoadID AS LoadID,
    [SystemLog].[GetInformationTypeID]('Error'), 
    (
      SELECT 
	      ERROR_NUMBER() AS "@Number",
	      ERROR_STATE() AS "@State",
	      ERROR_SEVERITY() AS "@Severity",
	      ERROR_MESSAGE() AS "Message",
	      ERROR_LINE() AS "Procedure/@Line",
	      ERROR_PROCEDURE() AS "Procedure"
	    FOR XML PATH('Error')
	  ) AS [Message],
	  @PackageLogID AS PackageLogID,
	  0 AS TaskLogID,
	  ERROR_NUMBER() AS Code,
	  GETDATE() AS ErrorDate,
	  @LKPCycleID AS CycleID;
	
  DECLARE @OTHERERRORMESSAGE VARCHAR(200);
  
  SELECT @OTHERERRORMESSAGE = ERROR_MESSAGE();

  RAISERROR('Error writting message to SystemLog.MessageLog table - %s', 16, 1, @OTHERERRORMESSAGE);	
END CATCH  


SELECT 0;
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [SystemLog].[CloseLoad]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE PROCEDURE [SystemLog].[CloseLoad]
@PackageName VARCHAR (255), @PackageGuid UNIQUEIDENTIFIER, @VersionBuild SMALLINT, @VersionMajor SMALLINT, @VersionMinor SMALLINT, @VersionComment VARCHAR (1000), @LoadID INT
AS
DECLARE @FailedMessageCount int;
DECLARE @PackageLogID INT;

BEGIN TRY
  -- Close the load with a status of fail if an error message is attached to the load
  SELECT @FailedMessageCount = COUNT(*)
  FROM SystemLog.MessageLog l
  WHERE l.LoadID = @LoadID
    AND l.InformationTypeID = [SystemLog].[GetInformationTypeID]('Error'); 
        
  IF @FailedMessageCount > 0
    BEGIN
      UPDATE SystemLog.LoadLog 
      SET EndDate = CAST(GETDATE() AS smalldatetime), StatusID =  [SystemLog].[GetStatusTypeID]('Failure')
      WHERE LoadID = @LoadID;
    END
  ELSE
    BEGIN
      UPDATE SystemLog.LoadLog 
      SET EndDate = CAST(GETDATE() AS smalldatetime), StatusID =  [SystemLog].[GetStatusTypeID]('Success')
      WHERE LoadID = @LoadID;
    END
END TRY
BEGIN CATCH
  /* Make sure the Meta data table PackageLog contains the information for this package */
  Exec [SystemLog].[PackageLogUps] 
    @PackageName, 
    @PackageGuid, 
    @VersionBuild, 
    @VersionMajor, 
    @VersionMinor, 
    @VersionComment,
    @PackageLogID OUTPUT

  /* Load could not be opened, insert an error message */
  INSERT INTO SystemLog.MessageLog([LoadID], [InformationTypeID], [Message], [PackageLogID], [TaskLogID], [Code], [ErrorDate], [CycleID])
  SELECT 
    @LoadID AS LoadID,
    [SystemLog].[GetInformationTypeID]('Error'), 
    (
      SELECT 
	      ERROR_NUMBER() AS "@Number",
	      ERROR_STATE() AS "@State",
	      ERROR_SEVERITY() AS "@Severity",
	      ERROR_MESSAGE() AS "Message",
	      ERROR_LINE() AS "Procedure/@Line",
	      ERROR_PROCEDURE() AS "Procedure"
	    FOR XML PATH('Error')
	  ) AS [Message],
	  @PackageLogID AS PackageLogID,
	  0 AS TaskLogID,
	  ERROR_NUMBER() AS Code,
	  GETDATE() AS ErrorDate,
	  l.CycleID AS CycleID
	FROM SystemLog.LoadLog l
	WHERE l.LoadID = @LoadID;
	
  DECLARE @ERRORMESSAGE VARCHAR(200);
  
  SELECT @ERRORMESSAGE = ERROR_MESSAGE();

  RAISERROR('Error closing load - %s', 16, 1, @ERRORMESSAGE);	
END CATCH  

SELECT 0;
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [SystemLog].[CloseCycle]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE PROCEDURE [SystemLog].[CloseCycle]
@PackageName VARCHAR (255), @PackageGuid UNIQUEIDENTIFIER, @VersionBuild SMALLINT, @VersionMajor SMALLINT, @VersionMinor SMALLINT, @VersionComment VARCHAR (1000), @CycleID INT
AS
DECLARE @FailedLoadCount int;
DECLARE @FailedMessageCount int;
DECLARE @PackageLogID INT;

BEGIN TRY

  -- Close the load with a status of fail if an error message is attached to the load or a load for the cycle
  -- failed.    
  SELECT @FailedLoadCount = COUNT(*)
  FROM SystemLog.LoadLog l
  WHERE l.CycleID = @CycleID
    AND l.StatusID = [SystemLog].[GetStatusTypeID]('Failure');
    
  SELECT @FailedMessageCount = COUNT(*)
  FROM SystemLog.MessageLog l
       JOIN SystemLog.InformationType t ON l.InformationTypeID = t.InformationTypeID 
  WHERE l.CycleID = @CycleID
    AND l.InformationTypeID = [SystemLog].[GetInformationTypeID]('Error'); 
        
  IF @FailedLoadCount > 0 OR @FailedMessageCount > 0
    BEGIN
      UPDATE SystemLog.CycleLog 
      SET EndDate = GETDATE(), StatusID = [SystemLog].[GetStatusTypeID]('Failure')
      WHERE CycleID = @CycleID;
    END
  ELSE
    BEGIN
      UPDATE SystemLog.CycleLog 
      SET EndDate = GETDATE(), StatusID = [SystemLog].[GetStatusTypeID]('Success')
      WHERE CycleID = @CycleID;
    END
END TRY
BEGIN CATCH
  /* Make sure the Meta data table PackageLog contains the information for this package */
  Exec [SystemLog].[PackageLogUps] 
    @PackageName, 
    @PackageGuid, 
    @VersionBuild, 
    @VersionMajor, 
    @VersionMinor, 
    @VersionComment,
    @PackageLogID OUTPUT

  /* Cycle could not be closed insert an error message */
  INSERT INTO SystemLog.MessageLog ([LoadID], [InformationTypeID], [Message], [PackageLogID], [TaskLogID], [Code], [ErrorDate], [CycleID])
  SELECT 
    0 AS LoadID,
    [SystemLog].[GetInformationTypeID]('Error'), 
    (
      SELECT 
	      ERROR_NUMBER() AS "@Number",
	      ERROR_STATE() AS "@State",
	      ERROR_SEVERITY() AS "@Severity",
	      ERROR_MESSAGE() AS "Message",
	      ERROR_LINE() AS "Procedure/@Line",
	      ERROR_PROCEDURE() AS "Procedure"
	    FOR XML PATH('Error')
	  ) AS [Message],
	  @PackageLogID AS PackageLogID,
	  0 AS TaskLogID,
	  ERROR_NUMBER() AS Code,
	  GETDATE() AS ErrorDate,
	  0 AS CycleID;
	
  DECLARE @ERRORMESSAGE VARCHAR(200);
  
  SELECT @ERRORMESSAGE = ERROR_MESSAGE();

  RAISERROR('Error closing cycle - %s', 16, 1, @ERRORMESSAGE);	
END CATCH  

Select 0;
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
DECLARE @VarDecimalSupported AS BIT;

SELECT @VarDecimalSupported = 0;

IF ((ServerProperty(N'EngineEdition') = 3)
    AND (((@@microsoftversion / power(2, 24) = 9)
          AND (@@microsoftversion & 0xffff >= 3024))
         OR ((@@microsoftversion / power(2, 24) = 10)
             AND (@@microsoftversion & 0xffff >= 1600))))
    SELECT @VarDecimalSupported = 1;

IF (@VarDecimalSupported > 0)
    BEGIN
        EXECUTE sp_db_vardecimal_storage_format N'$(DatabaseName)', 'ON';
    END


GO
PRINT N'Update complete.';


GO
